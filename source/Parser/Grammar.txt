variable : NAME ;

/*
	implemented as 
	complexVariable : this? variableOrFunction ; with ensurance it doesn't end with function
*/
complexVariable 
	: this? variableOrFunction '.' variable
	| this? variableOrFunction WS* '[' WS* expression WS* ']' // variableOrFunction bracketUnwrap
	| this? variable ;

variableAssign 
	: complexVariable CRLFWS* 
	(':=' | '+=' | '-=' | '*=' | '/=' | '//=' | '.=' | '|=' | '&=' | '^=' | '>>=' | '<<=') 
	WS* expression ;



variableOrFunction
	: variable
	| functionCall
	| variableOrFunction '.' variableOrFunction
	| variableOrFunction WS* '[' WS* expression WS* ']' ; // variableOrFunction bracketUnwrap

bracketUnwrap : WS* '[' WS* expression WS* ']' ;



functionCall : NAME WS* functionParameter ;
functionParameter : '(' WS* (expression? | (expression (CRLFWS* ',' WS* expression)*)) ')' ;
// no need to check WS right before bracket as CRLFWS is executed in case 2 & +ve case 1 AND WS in -ve case 1
// functionParamter is abstracted so that it can be reused in complexFunctions

/*
	implemented as
	complexFunction : this? variableOrFunction (if doesn't end with function : WS* functionParameter)
 */
complexFunction
	: this? variableOrFunction '.' functionCall
	| this? variableOrFunction WS* '[' WS* expression WS* ']' WS* functionParameter 
	// variableOrFunction bracketUnwrap WS* functionParameter
	| this? functionCall ;



this : 'this.' ; // abstacted away for code reuse 
WS : '\t' | ' ' ;
CRLF : '\r' | '\n' ;
CRLFWS : CRLF | WS ;